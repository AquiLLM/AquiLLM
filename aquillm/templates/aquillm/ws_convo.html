{% extends "aquillm/base.html" %}

{% block content %}
<div class="flex flex-col h-full">
    <div class="flex-1">
        <div id="conversation-root"></div>
    </div>
    
    <div class="border-t border-gray-200 p-4 mt-auto">
        <div id="exception-box" class="sticky top-0 z-50 font-mono text-red-700"></div>
        <!-- Collections Section -->
        <div class="max-w-4xl mx-auto mb-4">
            <details class="w-full">
                <summary class="cursor-pointer p-2 bg-gray-50 rounded-lg hover:bg-gray-100 flex items-center">
                    <span class="font-medium">Select Collections</span>
                    <span class="ml-2 text-sm text-gray-500" id="selected-count"></span>
                </summary>
                <div class="mt-2 p-2 border rounded-lg bg-white" id="collections-list">
                    <!-- Collections will be dynamically inserted here -->
                </div>
            </details>
        </div>
        
        <div class="flex gap-2 max-w-4xl mx-auto">
            <input 
            type="text" 
            id="message-input"
            class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:bg-gray-100 disabled:cursor-not-allowed"
            placeholder="Type your message here..."
            autocomplete="off"
            />
            <button 
            id="send-button"
            class="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:bg-blue-400 disabled:cursor-not-allowed"
            >
            Send
        </button>
    </div>
</div>
</div>
{% endblock %}

{% block scripts %}
<script type="module">
    import { init, classModule, propsModule, styleModule, eventListenersModule, h } from 'https://cdn.jsdelivr.net/npm/snabbdom@3.6.2/+esm';
    
    const patch = init([
    classModule,
    propsModule,
    styleModule,
    eventListenersModule
    ]);
    
    const convo_id = "{{ convo_id }}"
    
    let exceptionVnode = document.getElementById('exception-box');
    
    function updateExceptionBox(exception) {
        const newVnode = h('div', {
            class: {
                'font-mono': true,
                'text-red-700': true,
                'p-4': true,
                'mb-4': true,
                'bg-red-100': true,
                'rounded': true,
                'hidden': !exception,
            }
        }, exception || '');
        
        exceptionVnode = patch(exceptionVnode, newVnode);
    }
    
    let collections = []

    
    
    // Helper function to create spinner
    function createSpinner() {
        return h('div', {
            class: {
                'flex': true,
                'justify-center': true,
                'my-4': true
            }
        }, [
        h('div', {
            class: {
                'animate-spin': true,
                'rounded-full': true,
                'h-8': true,
                'w-8': true,
                'border-4': true,
                'border-blue-500': true,
                'border-t-transparent': true
            }
        })
        ]);
    }
    
    function createCollapsible(summary, content, isOpen = false) {
        return h('details', {
            props: { open: isOpen },
            class: { 'mt-1.5': true }
        }, [
        h('summary', {
            class: {
                'cursor-pointer': true,
                'text-blue-600': true
            }
        }, summary),
        h('div', {
            class: {
                'mt-1.5': true,
                'pl-2.5': true,
                'border-l-2': true,
                'border-gray-300': true
            }
        }, content)
        ]);
    }
    
    function renderToolResult(result, level = 0) {
        if (typeof result === 'object' && result !== null) {
            if (Array.isArray(result)) {
                return h('details', {
                    props: { open: level < 1 },
                    class: { 'mt-1': true }
                }, [
                h('summary', {
                    class: {
                        'cursor-pointer': true,
                        'font-mono': true,
                        'hover:text-blue-600': true
                    }
                }, 'Array'),
                h('div', { 
                    class: { 
                        'pl-4': true,
                        'border-l-2': true,
                        'border-gray-300': true,
                        'mt-1': true
                    } 
                }, result.map(item => renderToolResult(item, level + 1)))
                ]);
            } else {
                return h('div', {}, 
                Object.entries(result).map(([key, value]) => 
                typeof value === 'object' && value !== null ?
                h('details', {
                    props: { open: level < 1 },
                    class: { 'mt-1': true }
                }, [
                h('summary', {
                    class: {
                        'cursor-pointer': true,
                        'font-mono': true,
                        'hover:text-blue-600': true
                    }
                }, key),
                h('div', { 
                    class: { 
                        'pl-4': true,
                        'border-l-2': true,
                        'border-gray-300': true,
                        'mt-1': true
                    } 
                }, renderToolResult(value, level + 1))
                ]) :
                h('div', { class: { 'mt-1': true } }, [
                h('span', { 
                    class: { 
                        'font-mono': true,
                        'text-blue-600': true
                    } 
                }, `${key}: `),
                renderToolValue(value)
                ])
                )
                );
            }
        }
        return renderToolValue(result);
    }
    
    function renderToolValue(value) {
        if (typeof value === 'string') {
            return h('span', { 
                class: { 
                    'font-mono': true,
                    'text-green-600': true
                } 
            }, `"${value}"`);
        }
        return h('span', { 
            class: { 
                'font-mono': true,
                'text-purple-600': true
            } 
        }, String(value));
    }
    
    function shouldShowSpinner(messages) {
        if (messages.length === 0) return false;
        const lastMessage = messages[messages.length - 1];
        return (
        lastMessage.role === 'user' ||
        (lastMessage.role === 'assistant' && lastMessage.tool_call_input) ||
        (lastMessage.role === 'tool' && lastMessage.for_whom === 'assistant')
        );
    }
    
    function renderConversation(data) {
        const content = [
        ...data.messages.map(message => {
            const messageClasses = {
                'w-4/5': true,
                'mb-5': true,
                'p-2.5': true,
                'rounded-lg': true,
                'shadow-md': true,
                'whitespace-pre-wrap': true,
                'break-words': true
            };
            
            if (message.role === 'user') {
                Object.assign(messageClasses, {
                    'user-message': true,
                    'self-end': true,
                    'bg-lighter-primary': true,
                    'border': true,
                    'border-dashed': true,
                    'border-black': true,
                    'border-2': true
                });
            } else if (message.role === 'assistant') {
                Object.assign(messageClasses, {
                    'assistant-message': true,
                    'bg-deep-secondary': true,
                    'text-white': true
                });
            } else if (message.role === 'tool') {
                Object.assign(messageClasses, {
                    'bg-orange-100': true,
                    'border-l-4': true,
                    'border-orange-500': true
                });
            }
            
            const content = [];
            if (message.role !== 'tool') {
                content.push(h('p', { 
                    class: { 
                        'whitespace-pre-wrap': true,
                        'break-words': true
                    }
                }, message.content));
            }                
            
            if (message.role === 'assistant' && message.tool_call_input) {
                content.push(h('div', { 
                    class: { 
                        'mt-2.5': true,
                        'text-sm': true
                    }
                }, [
                h('strong', {}, `Called Tool: ${message.tool_call_name}`),
                createCollapsible(
                'View Tool Arguments',
                h('pre', {
                    class: {
                        'whitespace-pre-wrap': true,
                        'break-words': true,
                        'bg-gray-100': true,
                        'p-2': true,
                        'rounded': true,
                        'text-gray-800': true
                    }
                }, JSON.stringify(message.tool_call_input, null, 2))
                )
                ]));
            }
            
            if (message.role === 'tool') {
                const hasException = 'exception' in message.result_dict;
                const resultData = hasException ? message.result_dict.exception : message.result_dict.result;
                
                content.unshift(
                h('div', {
                    class: {
                        'mb-2': true,
                        'font-bold': true,
                        'text-orange-700': true
                    }
                }, `Tool Output: ${message.tool_name}`),
                createCollapsible(
                hasException ? 'View Exception' : 'View Results',
                h('div', {
                    class: {
                        'bg-white': true,
                        'p-2': true,
                        'rounded': true
                    }
                }, renderToolResult(resultData)),
                message.for_whom === 'user'
                )
                );
            }
            
            content.push(h('p', {
                class: {
                    'text-xs': true,
                    'mt-1.5': true,
                    'text-right': message.role === 'user'
                }
            }, new Date().toLocaleString()));
            
            return h('div', { class: messageClasses }, content);
        })
        ];
        
        if (shouldShowSpinner(data.messages)) {
            content.push(createSpinner());
        }
        
        return h('div', { 
            class: { 
                'flex': true,
                'flex-col': true,
                'max-w-full': true,
                'h-full': true,
                'mx-auto': true,
                'overflow-y-auto': true
            }
        }, content);
    }
    
    let vnode = document.getElementById('conversation-root');
    let ws;
    let conversation = { messages: [] };
    let connectionAttempts = 0;
    const MAX_RECONNECTION_ATTEMPTS = 5;
    const CONNECTION_TIMEOUT = 5000; 
    
    
    function setInputState(disabled) {
        const input = document.getElementById('message-input');
        const button = document.getElementById('send-button');
        input.disabled = disabled;
        button.disabled = disabled;
    }
    
    
    function initWebSocket() {
        collections = fetchCollections()
        .then(data => {
            collections = data;
        });
        if (connectionAttempts >= MAX_RECONNECTION_ATTEMPTS) {
            updateExceptionBox('Maximum reconnection attempts reached. Please refresh the page.');
            return;
        }
        
        connectionAttempts++;
        updateExceptionBox('Attempting to connect... (Attempt ' + connectionAttempts + ' of ' + MAX_RECONNECTION_ATTEMPTS + ')');
        
        try {
            const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';

            ws = new WebSocket(protocol + window.location.host + '/ws/convo/' + convo_id + '/');
            
            // Set connection timeout
            const timeoutId = setTimeout(() => {
                if (ws.readyState !== WebSocket.OPEN) {
                    ws.close();
                    updateExceptionBox('Connection timeout. Retrying...');
                    setTimeout(initWebSocket, 2000);
                }
            }, CONNECTION_TIMEOUT);
            
            ws.onopen = () => {
                console.log('Connected to chat server');
                clearTimeout(timeoutId);
                connectionAttempts = 0; // Reset counter on successful connection
                setInputState(false);
                updateExceptionBox(''); // Clear any existing error
            };
            
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.exception) {
                        console.error('Server error:', data.exception);
                        updateExceptionBox(data.exception);
                        setInputState(false);
                        return;
                    }
                    
                    updateExceptionBox('');
                    
                    if (data.conversation) {
                        conversation = data.conversation;
                        updateConversation(conversation);
                        if (conversation.messages.length) {
                            const lastMessage = conversation.messages[conversation.messages.length - 1];
                            const shouldEnableInput = 
                            (lastMessage.role === 'assistant' && !lastMessage.tool_call_input) ||
                            (lastMessage.role === 'tool' && lastMessage.for_whom === 'user');
                            
                            setInputState(!shouldEnableInput);
                        }
                    }
                } catch (error) {
                    updateExceptionBox('Error processing message: ' + error.message);
                }
            };
            
            ws.onclose = (event) => {
                clearTimeout(timeoutId);
                console.log('Disconnected from chat server', event.code, event.reason);
                setInputState(true);
                
                let message = 'Disconnected from server. ';
                if (event.code === 1006) {
                    message += 'Abnormal closure. ';
                } else if (event.code === 1015) {
                    message += 'TLS handshake failed. ';
                }
                message += 'Attempting to reconnect...';
                
                updateExceptionBox(message);
                setTimeout(initWebSocket, 2000);
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateExceptionBox('Connection error occurred. Retrying...');
            };
            
        } catch (error) {
            console.error('Error creating WebSocket:', error);
            updateExceptionBox('Failed to create connection: ' + error.message);
            setTimeout(initWebSocket, 2000);
        }
    }
    
    function sendMessage() {
        const input = document.getElementById('message-input');
        const message = input.value.trim();
        
        if (!message || !ws || ws.readyState !== WebSocket.OPEN) return;
        
        setInputState(true);
        conversation.messages.push({role: 'user', content: message});
        updateConversation(conversation);
        
        const payload = {
            action: 'replace',
            messages: conversation.messages,
            collections: Array.from(selectedCollections)
        };
        
        ws.send(JSON.stringify(payload));
        input.value = '';
    }
    
    function updateConversation(newData) {
        vnode = patch(vnode, renderConversation(newData));
    }
    
    document.getElementById('send-button').addEventListener('click', sendMessage);
    
    document.getElementById('message-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            sendMessage();
        }
    });
    let selectedCollections = new Set();
    
    async function fetchCollections() {
        try {
            const response = await fetch("{% url 'get_collections_json' %}");
            if (!response.ok) {
                throw new Error(`Http error: ${response.status}`);
            }
            const data = await response.json();
            collections = data.collections;
            collections.forEach(collection => selectedCollections.add(collection.id));
            updateSelectedCount();
            renderCollections();
            updateSelectedCount();
            return collections;
        } catch (error) {
            console.error('Error fetching collections:', error)
            throw error;
        }
    }
    
    function renderCollections() {
        const container = document.getElementById('collections-list');
        container.innerHTML = '';
        
        collections.forEach(collection => {
            const div = document.createElement('div');
            div.className = 'flex items-center p-2 hover:bg-gray-50 rounded';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `collection-${collection.id}`;
            checkbox.className = 'h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500';
            checkbox.checked = selectedCollections.has(collection.id);
            
            const label = document.createElement('label');
            label.htmlFor = `collection-${collection.id}`;
            label.className = 'ml-2 text-sm text-gray-700';
            label.textContent = collection.name;
            
            checkbox.addEventListener('change', () => {
                if (checkbox.checked) {
                    selectedCollections.add(collection.id);
                } else {
                    selectedCollections.delete(collection.id);
                }
                updateSelectedCount();
            });
            
            div.appendChild(checkbox);
            div.appendChild(label);
            container.appendChild(div);
        });
    }
    
    function updateSelectedCount() {
        const countElement = document.getElementById('selected-count');
        const count = selectedCollections.size;
        countElement.textContent = count ? `(${count} selected)` : '';
    }
    
    initWebSocket();
    
    window.updateConversation = updateConversation;
</script>
{% endblock %}